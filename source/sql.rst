Learning SQL
*************
学习SQL的一些基本语法。

一些基本术语：\ **实体**\ ，\ **列**\ ，\ **行**\ ，\ **表**\ ，\ **结果集**\
，\ **主键**\ ，\ **外键**\ ，\ **事务**\ ，\ **索引**\ ，\ **视图**\ ，\ **约\
束**\ 。

SQL语言可以分为几个模块：\ **SQL方案语句**\ ，用于定义存储于数据库中的数据结\
构；\ **SQL数据语句**\ ，用于操作数据库中的数据；\ **SQL事务语句**\ ，用于开\
始、结束或回滚事务。

条件过滤-WHERE子句
==================
* 比较操作符有：\ ``=, !=, <>, <, >, LIKE, IN, BETWEEN, IS``\。
* 逻辑操作符有：\ ``AND, NOT, OR``\ 。

范围条件-\ **BETWEEN**
----------------------
即：\ ``a > 0 and a < 10``\ 等同于\ ``a BETWEEN 0 10``\ 。例如下列两条SQL语句等\
同。

.. sourcecode:: sql

    SELECT name FROM employee WHERE start_time < '2007-01-01' AND start_time < '2005-01-01'

    SELECT name FROM employee WHERE start_time BETWEEN '2005-01-01' '2007-01-01'

成员条件-\ **IN**
-----------------
当对某个值的限制为一个有限集合时，SQL可以写为：

.. sourcecode:: sql

    SELECT name FROM employee WHERE district = 'CHN' OR district = 'CHK' OR district = 'CD' OR district = 'SAV'

使用\ **IN**\ 可以写的更为简洁，如：

.. sourcecode:: sql

    SELECT name FROM employee WHERE district IN ('CHN', 'CHK', 'CD', 'SAV')

除了自定义集合，也可以使用子查询产生的集合。如：

.. sourcecode:: sql

    SELECT name FROM employee WHERE district IN (SELECT district_code IN district WHERE people_count < 1000000)

对于\ **IN**\ 也可以使用“非”操作，即表示不在集合内。关键字为：\ **NOT IN**\ 。

.. sourcecode:: sql

    SELECT name FROM employee WHERE district NOT IN ('CHN', 'CHK', 'CD', 'SAV')

匹配条件-\ **LIKE**\， 通配符，正则表达式
------------------------------------------
在各种匹配条件中，也可以使用内置函数。如：

.. sourcecode:: sql

    SELECT name FROM employee WHERE LEFT(lname, 1) = 'T'

上面使用内置函数\ ``LEFT``\ 提取\ *lname*\ 的首字母，然后与字母“T”进行比较。

* ``LIKE``\ 可以使用通配符和一些简单的正则表达式。如下表：

+--------+--------------------------------------------------------+
| 符号   | 匹配                                                   |
+========+========================================================+
| \%     | 匹配任意数目的字符（包括0）。类似于正则表达式中的“.\*” |
+--------+--------------------------------------------------------+
| \_     | 匹配一个字符。类似于正则表达式中的“.”                  |
+--------+--------------------------------------------------------+
| [abc]  | 匹配集合中的元素                                       |
+--------+--------------------------------------------------------+
| [^abc] | 不匹配集合中的元素                                     |
+--------+--------------------------------------------------------+

* 另外可以使用函数\ ``REGEXP``\ 来使用正则表达式来进行匹配。如：

.. sourcecode:: sql

    SELECT name FROM employee WHERE lname REGEXP '^[FG]'

在Oracle中使用函数\ ``regexp_like``\ 代替\ ``REGEXP``\ ，而在MS SQL SERVER中可\
以直接在\ ``LIKE``\ 中使用正则表达式。

关于\ **NULL**\ 值的操作
------------------------
当使用\ ``NULL``\ 需要注意：

* 表达式的值可以为“\ ``NULL``\ ”，但为不能等于“\ ``NULL``\ ”。
* 两个“\ ``NULL``\ ”不能判断为相等。如果利用“\ ``=``\ ”来判断两个“\ ``NULL``\ ”\
  值，将不会得到正确的结果，而且服务器也不会发出出错提示，这是相当危险的。
* 判断两个“\ ``NULL`` ”相等，需要用到操作符“\ ``IS``\ ”。如下：

.. sourcecode:: sql

    /* 假定superior_emp_id存在NULL值 */
    /* 错误的做法 */
    SELECT emp_id, name FROM employee WHERE superior_emp_id = NULL
    /* 正确的做法 */
    SELECT emp_id, name FROM employee WHERE superior_emp_id IS NULL

另外进行条件筛选时也要考虑全面，注意\ ``NULL``\ 值的存在

分组与聚集
==========
这一部分貌似有点像简单的数据分析和挖掘，当然是最最初级的。
它主要包括：\ **分组**\ 和\ **聚集**\ 两种操作。

* **分组**\ 即针对某一特征的不同值进行分组，分块。
* **聚集**\ 其实是对分组后，每组中的数据进行统计分析。SQL只提供了一些简单的统计
  函数。如\ MAX_\ ，\ MIN_ \ ，SUM_ \ ，COUNT_\ 等。

.. _MAX:

.. _MIN:

.. _SUM:

.. _COUNT:

子查询
======



多表查询与连接
==============



条件逻辑
========




事务
====
锁的策略
---------
锁是数据库用于控制数据被并行使用的一种机制。当数据库的一些内容被锁定时，任何对\
这个数据的修改（甚至是读取）都必须等待锁被释放。主流有两种锁策略：

* 数据库的写操作必须申请并获得写锁才能修改数据，而读操作必须申请和获得读锁才能\
  查询数据，多用户可以同时读取数据（即读锁可以分配多个）。一个表（或页或行）只\
  能分配一次分配一个写锁，并且拒绝读请求直至写锁释放。
  **读写是相互排斥的，读写都必须申请锁。**\ SQL Server才用的是此策略，MySQL取决\  于选择的存储引擎。
* 数据库的写操作必须申请并获得锁才能修改数据，而读操作不需要锁。但是数据库服务\
  器必须保证读操作从开始到结束看到的是一个一致的数据视图。此方法称为\ **版本控\
  制**\ 。\ **写操作需要锁，读不需要锁，但服务器必须保证读时数据一致。**\ Orale\
  采取的是此策略。

锁的粒度
--------
* **表锁**  阻止多用户同时操作一个表的数据
* **页锁**  阻止多用户同时操作表中同一页（2-16KB内存空间）的数据
* **行锁**  阻止多用户同时操作表中同一行的数据

SQL Server使用表锁，页锁和行锁，Oracle只有行锁，MySQL取决于存储引擎的选择。在某\些情况下，SQL Server会逐步升级锁，Oracle从不升级锁


索引与约束
==========

视图
====
